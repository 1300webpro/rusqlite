var searchIndex = {};
searchIndex["rusqlite"] = {"doc":"Rusqlite is an ergonomic wrapper for using SQLite from Rust. It attempts to expose\nan interface similar to [rust-postgres](https://github.com/sfackler/rust-postgres).","items":[[3,"Transaction","rusqlite","Represents a transaction on a database connection.",null,null],[3,"CachedStatement","","Cacheable statement.",null,null],[3,"LoadExtensionGuard","","RAII guard temporarily enabling SQLite extensions to be loaded.",null,null],[3,"Connection","","A connection to a SQLite database.",null,null],[3,"OpenFlags","","Flags for opening SQLite database connections.\nSee [sqlite3_open_v2](http://www.sqlite.org/c3ref/open.html) for details.",null,null],[3,"Statement","","A prepared statement.",null,null],[3,"MappedRows","","An iterator over the mapped resulting rows of a query.",null,null],[3,"AndThenRows","","An iterator over the mapped resulting rows of a query, with an Error type\nunifying with Error.",null,null],[3,"Rows","","An handle for the resulting rows of a query.",null,null],[3,"Row","","A single result row of a query.",null,null],[4,"TransactionBehavior","","Options for transaction behavior. See [BEGIN\nTRANSACTION](http://www.sqlite.org/lang_transaction.html) for details.",null,null],[13,"Deferred","","",0,null],[13,"Immediate","","",0,null],[13,"Exclusive","","",0,null],[4,"Error","","Enum listing possible errors from rusqlite.",null,null],[13,"SqliteFailure","","An error from an underlying SQLite call.",1,null],[13,"SqliteSingleThreadedMode","","Error reported when attempting to open a connection when SQLite was configured to\nallow single-threaded use only.",1,null],[13,"FromSqlConversionFailure","","An error case available for implementors of the `FromSql` trait.",1,null],[13,"Utf8Error","","Error converting a string to UTF-8.",1,null],[13,"NulError","","Error converting a string to a C-compatible string because it contained an embedded nul.",1,null],[13,"InvalidParameterName","","Error when using SQL named parameters and passing a parameter name not present in the SQL.",1,null],[13,"InvalidPath","","Error converting a file path to a string.",1,null],[13,"ExecuteReturnedResults","","Error returned when an `execute` call returns rows.",1,null],[13,"QueryReturnedNoRows","","Error when a query that was expected to return at least one row (e.g., for `query_row`)\ndid not return any.",1,null],[13,"InvalidColumnIndex","","Error when the value of a particular column is requested, but the index is out of range\nfor the statement.",1,null],[13,"InvalidColumnName","","Error when the value of a named column is requested, but no column matches the name\nfor the statement.",1,null],[13,"InvalidColumnType","","Error when the value of a particular column is requested, but the type of the result in\nthat column cannot be converted to the requested Rust type.",1,null],[13,"StatementChangedRows","","Error when a query that was expected to insert one row did not insert any or insert many.",1,null],[13,"StatementFailedToInsertRow","","Error when a query that was expected to insert a row did not change the connection&#39;s\nlast_insert_rowid().",1,null],[13,"InvalidFunctionParameterType","","Error returned by `functions::Context::get` when the function argument cannot be converted\nto the requested type.",1,null],[13,"UserFunctionError","","An error case available for implementors of custom user functions (e.g.,\n`create_scalar_function`).",1,null],[4,"DatabaseName","","Name for a database within a SQLite connection.",null,null],[13,"Main","","The main database.",2,null],[13,"Temp","","The temporary database (e.g., any &quot;CREATE TEMPORARY TABLE&quot; tables).",2,null],[13,"Attached","","A database that has been attached via &quot;ATTACH DATABASE ...&quot;.",2,null],[0,"types","","Traits dealing with SQLite data types.",null,null],[11,"clone","libsqlite3_sys::bindgen","",3,{"inputs":[{"name":"struct_sqlite3_file"}],"output":{"name":"struct_sqlite3_file"}}],[11,"default","","",3,{"inputs":[],"output":{"name":"struct_sqlite3_file"}}],[11,"clone","","",4,{"inputs":[{"name":"struct_sqlite3_io_methods"}],"output":{"name":"struct_sqlite3_io_methods"}}],[11,"default","","",4,{"inputs":[],"output":{"name":"struct_sqlite3_io_methods"}}],[11,"clone","","",5,{"inputs":[{"name":"struct_sqlite3_vfs"}],"output":{"name":"struct_sqlite3_vfs"}}],[11,"default","","",5,{"inputs":[],"output":{"name":"struct_sqlite3_vfs"}}],[11,"clone","","",6,{"inputs":[{"name":"struct_sqlite3_mem_methods"}],"output":{"name":"struct_sqlite3_mem_methods"}}],[11,"default","","",6,{"inputs":[],"output":{"name":"struct_sqlite3_mem_methods"}}],[11,"clone","","",7,{"inputs":[{"name":"struct_sqlite3_module"}],"output":{"name":"struct_sqlite3_module"}}],[11,"default","","",7,{"inputs":[],"output":{"name":"struct_sqlite3_module"}}],[11,"clone","","",8,{"inputs":[{"name":"struct_sqlite3_index_info"}],"output":{"name":"struct_sqlite3_index_info"}}],[11,"default","","",8,{"inputs":[],"output":{"name":"struct_sqlite3_index_info"}}],[11,"clone","","",9,{"inputs":[{"name":"struct_sqlite3_index_constraint"}],"output":{"name":"struct_sqlite3_index_constraint"}}],[11,"default","","",9,{"inputs":[],"output":{"name":"struct_sqlite3_index_constraint"}}],[11,"clone","","",10,{"inputs":[{"name":"struct_sqlite3_index_orderby"}],"output":{"name":"struct_sqlite3_index_orderby"}}],[11,"default","","",10,{"inputs":[],"output":{"name":"struct_sqlite3_index_orderby"}}],[11,"clone","","",11,{"inputs":[{"name":"struct_sqlite3_index_constraint_usage"}],"output":{"name":"struct_sqlite3_index_constraint_usage"}}],[11,"default","","",11,{"inputs":[],"output":{"name":"struct_sqlite3_index_constraint_usage"}}],[11,"clone","","",12,{"inputs":[{"name":"struct_sqlite3_vtab"}],"output":{"name":"struct_sqlite3_vtab"}}],[11,"default","","",12,{"inputs":[],"output":{"name":"struct_sqlite3_vtab"}}],[11,"clone","","",13,{"inputs":[{"name":"struct_sqlite3_vtab_cursor"}],"output":{"name":"struct_sqlite3_vtab_cursor"}}],[11,"default","","",13,{"inputs":[],"output":{"name":"struct_sqlite3_vtab_cursor"}}],[11,"clone","","",14,{"inputs":[{"name":"struct_sqlite3_mutex_methods"}],"output":{"name":"struct_sqlite3_mutex_methods"}}],[11,"default","","",14,{"inputs":[],"output":{"name":"struct_sqlite3_mutex_methods"}}],[11,"clone","","",15,{"inputs":[{"name":"struct_sqlite3_pcache_page"}],"output":{"name":"struct_sqlite3_pcache_page"}}],[11,"default","","",15,{"inputs":[],"output":{"name":"struct_sqlite3_pcache_page"}}],[11,"clone","","",16,{"inputs":[{"name":"struct_sqlite3_pcache_methods2"}],"output":{"name":"struct_sqlite3_pcache_methods2"}}],[11,"default","","",16,{"inputs":[],"output":{"name":"struct_sqlite3_pcache_methods2"}}],[11,"clone","","",17,{"inputs":[{"name":"struct_sqlite3_pcache_methods"}],"output":{"name":"struct_sqlite3_pcache_methods"}}],[11,"default","","",17,{"inputs":[],"output":{"name":"struct_sqlite3_pcache_methods"}}],[11,"clone","","",18,{"inputs":[{"name":"struct_sqlite3_rtree_geometry"}],"output":{"name":"struct_sqlite3_rtree_geometry"}}],[11,"default","","",18,{"inputs":[],"output":{"name":"struct_sqlite3_rtree_geometry"}}],[11,"clone","","",19,{"inputs":[{"name":"struct_sqlite3_rtree_query_info"}],"output":{"name":"struct_sqlite3_rtree_query_info"}}],[11,"default","","",19,{"inputs":[],"output":{"name":"struct_sqlite3_rtree_query_info"}}],[11,"clone","","",20,{"inputs":[{"name":"struct___va_list_tag"}],"output":{"name":"struct___va_list_tag"}}],[11,"default","","",20,{"inputs":[],"output":{"name":"struct___va_list_tag"}}],[11,"eq","libsqlite3_sys::error","",21,{"inputs":[{"name":"errorcode"},{"name":"errorcode"}],"output":{"name":"bool"}}],[11,"fmt","","",21,{"inputs":[{"name":"errorcode"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",21,{"inputs":[{"name":"errorcode"}],"output":{"name":"errorcode"}}],[11,"eq","","",22,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"bool"}}],[11,"fmt","","",22,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",22,{"inputs":[{"name":"error"}],"output":{"name":"error"}}],[11,"new","","",22,{"inputs":[{"name":"i32"}],"output":{"name":"error"}}],[11,"fmt","","",22,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",22,{"inputs":[{"name":"error"}],"output":{"name":"str"}}],[6,"sqlite3_stmt","rusqlite::types","",null,null],[5,"sqlite3_column_type","","",null,null],[17,"SQLITE_INTEGER","","",null,null],[17,"SQLITE_FLOAT","","",null,null],[17,"SQLITE_TEXT","","",null,null],[17,"SQLITE_BLOB","","",null,null],[17,"SQLITE_NULL","","",null,null],[3,"Null","","Empty struct that can be used to fill in a query parameter as `NULL`.",null,null],[4,"Value","","Dynamic type value (http://sqlite.org/datatype3.html)\nValue&#39;s type is dictated by SQLite (not by the caller).",null,null],[13,"Null","","The value is a `NULL` value.",23,null],[13,"Integer","","The value is a signed integer.",23,null],[13,"Real","","The value is a floating point number.",23,null],[13,"Text","","The value is a text string.",23,null],[13,"Blob","","The value is a blob of data",23,null],[11,"bind_parameter","time","",24,null],[11,"column_result","","",24,null],[11,"column_has_valid_sqlite_type","","",24,null],[11,"bind_parameter","chrono::naive::date","",25,null],[11,"column_result","","",25,null],[11,"column_has_valid_sqlite_type","","",25,null],[11,"bind_parameter","chrono::naive::time","",26,null],[11,"column_result","","",26,null],[11,"column_has_valid_sqlite_type","","",26,null],[11,"bind_parameter","chrono::naive::datetime","",27,null],[11,"column_result","","",27,null],[11,"column_has_valid_sqlite_type","","",27,null],[11,"bind_parameter","chrono::datetime","",28,null],[11,"column_result","","",28,null],[11,"column_has_valid_sqlite_type","","",28,null],[11,"column_result","","",28,null],[11,"column_has_valid_sqlite_type","","",28,null],[11,"bind_parameter","serde_json::value","",29,null],[11,"column_result","","",29,null],[8,"ToSql","rusqlite::types","A trait for types that can be converted into SQLite values.",null,null],[10,"bind_parameter","","",30,null],[8,"FromSql","","A trait for types that can be created from a SQLite value.",null,null],[10,"column_result","","",31,null],[11,"column_has_valid_sqlite_type","","FromSql types can implement this method and use sqlite3_column_type to check that\nthe type reported by SQLite matches a type suitable for Self. This method is used\nby `Row::get_checked` to confirm that the column contains a valid type before\nattempting to retrieve the value.",31,null],[11,"bind_parameter","","",32,null],[11,"bind_parameter","","",33,null],[11,"bind_parameter","collections::string","",34,null],[11,"bind_parameter","collections::vec","",35,null],[11,"bind_parameter","core::option","",36,null],[11,"clone","rusqlite::types","",37,{"inputs":[{"name":"null"}],"output":{"name":"null"}}],[11,"bind_parameter","","",37,null],[11,"column_result","","",32,null],[11,"column_has_valid_sqlite_type","","",32,null],[11,"column_result","","",33,null],[11,"column_has_valid_sqlite_type","","",33,null],[11,"column_result","collections::string","",34,null],[11,"column_has_valid_sqlite_type","","",34,null],[11,"column_result","collections::vec","",35,null],[11,"column_has_valid_sqlite_type","","",35,null],[11,"column_result","core::option","",36,null],[11,"column_has_valid_sqlite_type","","",36,null],[11,"eq","rusqlite::types","",23,{"inputs":[{"name":"value"},{"name":"value"}],"output":{"name":"bool"}}],[11,"ne","","",23,{"inputs":[{"name":"value"},{"name":"value"}],"output":{"name":"bool"}}],[11,"fmt","","",23,{"inputs":[{"name":"value"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",23,{"inputs":[{"name":"value"}],"output":{"name":"value"}}],[11,"column_result","","",23,null],[11,"clone","rusqlite","",0,{"inputs":[{"name":"transactionbehavior"}],"output":{"name":"transactionbehavior"}}],[11,"new","","Begin a new transaction. Cannot be nested; see `savepoint` for nested transactions.",38,{"inputs":[{"name":"connection"},{"name":"transactionbehavior"}],"output":{"name":"result"}}],[11,"savepoint","","Starts a new [savepoint](http://www.sqlite.org/lang_savepoint.html), allowing nested\ntransactions.",38,{"inputs":[{"name":"transaction"}],"output":{"name":"result"}}],[11,"savepoint_with_name","","Create a new savepoint with a custom savepoint name. See `savepoint()`.",38,{"inputs":[{"name":"transaction"},{"name":"t"}],"output":{"name":"result"}}],[11,"drop_behavior","","Get the current setting for what happens to the transaction when it is dropped.",38,{"inputs":[{"name":"transaction"}],"output":{"name":"dropbehavior"}}],[11,"set_drop_behavior","","Configure the transaction to perform the specified action when it is dropped.",38,{"inputs":[{"name":"transaction"},{"name":"dropbehavior"}],"output":null}],[11,"commit","","A convenience method which consumes and commits a transaction.",38,{"inputs":[{"name":"transaction"}],"output":{"name":"result"}}],[11,"rollback","","A convenience method which consumes and rolls back a transaction.",38,{"inputs":[{"name":"transaction"}],"output":{"name":"result"}}],[11,"finish","","Consumes the transaction, committing or rolling back according to the current setting\n(see `drop_behavior`).",38,{"inputs":[{"name":"transaction"}],"output":{"name":"result"}}],[11,"deref","","",38,{"inputs":[{"name":"transaction"}],"output":{"name":"connection"}}],[11,"drop","","",38,{"inputs":[{"name":"transaction"}],"output":null}],[11,"transaction","","Begin a new transaction with the default behavior (DEFERRED).",39,{"inputs":[{"name":"connection"}],"output":{"name":"result"}}],[11,"transaction_with_behavior","","Begin a new transaction with a specified behavior.",39,{"inputs":[{"name":"connection"},{"name":"transactionbehavior"}],"output":{"name":"result"}}],[11,"savepoint","","Begin a new savepoint with the default behavior (DEFERRED).",39,{"inputs":[{"name":"connection"}],"output":{"name":"result"}}],[11,"savepoint_with_name","","Begin a new savepoint with a specified name.",39,{"inputs":[{"name":"connection"},{"name":"t"}],"output":{"name":"result"}}],[11,"prepare_cached","","Prepare a SQL statement for execution, returning a previously prepared (but\nnot currently in-use) statement if one is available. The returned statement\nwill be cached for reuse by future calls to `prepare_cached` once it is\ndropped.",39,{"inputs":[{"name":"connection"},{"name":"str"}],"output":{"name":"result"}}],[11,"set_prepared_statement_cache_capacity","","Set the maximum number of cached prepared statements this connection will hold.\nBy default, a connection will hold a relatively small number of cached statements.\nIf you need more, or know that you will not use cached statements, you can set\nthe capacity manually using this method.",39,{"inputs":[{"name":"connection"},{"name":"usize"}],"output":null}],[11,"deref","","",40,{"inputs":[{"name":"cachedstatement"}],"output":{"name":"statement"}}],[11,"deref_mut","","",40,{"inputs":[{"name":"cachedstatement"}],"output":{"name":"statement"}}],[11,"drop","","",40,{"inputs":[{"name":"cachedstatement"}],"output":null}],[11,"discard","","",40,{"inputs":[{"name":"cachedstatement"}],"output":null}],[11,"execute_named","","Convenience method to prepare and execute a single SQL statement with named parameter(s).",39,null],[11,"query_row_named","","Convenience method to execute a query with named parameter(s) that is expected to return\na single row.",39,null],[11,"parameter_index","","Return the index of an SQL parameter given its name.",41,{"inputs":[{"name":"statement"},{"name":"str"}],"output":{"name":"result"}}],[11,"execute_named","","Execute the prepared statement with named parameter(s). If any parameters\nthat were in the prepared statement are not included in `params`, they\nwill continue to use the most-recently bound value from a previous call\nto `execute_named`, or `NULL` if they have never been bound.",41,null],[11,"query_named","","Execute the prepared statement with named parameter(s), returning a handle for the\nresulting rows. If any parameters that were in the prepared statement are not included in\n`params`, they will continue to use the most-recently bound value from a previous call to\n`query_named`, or `NULL` if they have never been bound.",41,null],[11,"query_map_named","","Execute the prepared statement with named parameter(s), returning an iterator over the\nresult of calling the mapping function over the query&#39;s rows. If any parameters that were\nin the prepared statement are not included in `params`, they will continue to use the\nmost-recently bound value from a previous call to `query_named`, or `NULL` if they have\nnever been bound.",41,null],[11,"query_and_then_named","","Execute the prepared statement with named parameter(s), returning an iterator over the\nresult of calling the mapping function over the query&#39;s rows. If any parameters that were\nin the prepared statement are not included in `params`, they will continue to use the\nmost-recently bound value from a previous call to `query_named`, or `NULL` if they have\nnever been bound.",41,null],[11,"fmt","","",1,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",1,{"inputs":[{"name":"utf8error"}],"output":{"name":"error"}}],[11,"from","","",1,{"inputs":[{"name":"nulerror"}],"output":{"name":"error"}}],[11,"fmt","","",1,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",1,{"inputs":[{"name":"error"}],"output":{"name":"str"}}],[11,"cause","","",1,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[11,"insert","","Execute an INSERT and return the ROWID.",41,null],[11,"exists","","Return `true` if a query in the SQL statement it executes returns one or more rows\nand `false` if the SQL returns an empty set.",41,null],[11,"new","","Attempt to enable loading extensions. Loading extensions will be disabled when this\nguard goes out of scope. Cannot be meaningfully nested.",42,{"inputs":[{"name":"connection"}],"output":{"name":"result"}}],[11,"drop","","",42,{"inputs":[{"name":"loadextensionguard"}],"output":null}],[0,"trace","","Tracing and profiling functions. Error and warning log.",null,null],[5,"config_log","rusqlite::trace","Set up the process-wide SQLite error logging callback.\nThis function is marked unsafe for two reasons:",null,{"inputs":[{"name":"option"}],"output":{"name":"result"}}],[5,"log","","Write a message into the error log established by `config_log`.",null,{"inputs":[{"name":"c_int"},{"name":"str"}],"output":null}],[11,"trace","rusqlite","Register or clear a callback function that can be used for tracing the execution of SQL\nstatements.",39,{"inputs":[{"name":"connection"},{"name":"option"}],"output":null}],[11,"profile","","Register or clear a callback function that can be used for profiling the execution of SQL\nstatements.",39,{"inputs":[{"name":"connection"},{"name":"option"}],"output":null}],[0,"backup","","Online SQLite backup API.",null,null],[3,"Progress","rusqlite::backup","Struct specifying the progress of a backup. The percentage completion can\nbe calculated as `(pagecount - remaining) / pagecount`. The progress of a\nbackup is as of the last call to `step` - if the source database is\nmodified after a call to `step`, the progress value will become outdated\nand potentially incorrect.",null,null],[12,"remaining","","Number of pages in the source database that still need to be backed up.",43,null],[12,"pagecount","","Total number of pages in the source database.",43,null],[3,"Backup","","A handle to an online backup.",null,null],[4,"StepResult","","Possible successful results of calling `Backup::step`.",null,null],[13,"Done","","The backup is complete.",44,null],[13,"More","","The step was successful but there are still more pages that need to be backed up.",44,null],[13,"Busy","","The step failed because appropriate locks could not be aquired. This is\nnot a fatal error - the step can be retried.",44,null],[13,"Locked","","The step failed because the source connection was writing to the\ndatabase. This is not a fatal error - the step can be retried.",44,null],[11,"backup","rusqlite","Back up the `name` database to the given destination path.\nIf `progress` is not `None`, it will be called periodically\nuntil the backup completes.",39,{"inputs":[{"name":"connection"},{"name":"databasename"},{"name":"p"},{"name":"option"}],"output":{"name":"result"}}],[11,"restore","","Restore the given source path into the `name` database.\nIf `progress` is not `None`, it will be called periodically\nuntil the restore completes.",39,{"inputs":[{"name":"connection"},{"name":"databasename"},{"name":"p"},{"name":"option"}],"output":{"name":"result"}}],[11,"eq","rusqlite::backup","",44,{"inputs":[{"name":"stepresult"},{"name":"stepresult"}],"output":{"name":"bool"}}],[11,"fmt","","",44,{"inputs":[{"name":"stepresult"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",44,{"inputs":[{"name":"stepresult"}],"output":{"name":"stepresult"}}],[11,"fmt","","",43,{"inputs":[{"name":"progress"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",43,{"inputs":[{"name":"progress"}],"output":{"name":"progress"}}],[11,"new","","Attempt to create a new handle that will allow backups from `from` to\n`to`. Note that `to` is a `&amp;mut` - this is because SQLite forbids any\nAPI calls on the destination of a backup while the backup is taking\nplace.",45,{"inputs":[{"name":"connection"},{"name":"connection"}],"output":{"name":"result"}}],[11,"new_with_names","","Attempt to create a new handle that will allow backups from the\n`from_name` database of `from` to the `to_name` database of `to`. Note\nthat `to` is a `&amp;mut` - this is because SQLite forbids any API calls on\nthe destination of a backup while the backup is taking place.",45,{"inputs":[{"name":"connection"},{"name":"databasename"},{"name":"connection"},{"name":"databasename"}],"output":{"name":"result"}}],[11,"progress","","Gets the progress of the backup as of the last call to `step`.",45,{"inputs":[{"name":"backup"}],"output":{"name":"progress"}}],[11,"step","","Attempts to back up the given number of pages. If `num_pages` is\nnegative, will attempt to back up all remaining pages. This will hold a\nlock on the source database for the duration, so it is probably not\nwhat you want for databases that are currently active (see\n`run_to_completion` for a better alternative).",45,{"inputs":[{"name":"backup"},{"name":"c_int"}],"output":{"name":"result"}}],[11,"run_to_completion","","Attempts to run the entire backup. Will call `step(pages_per_step)` as\nmany times as necessary, sleeping for `pause_between_pages` between\neach call to give the source database time to process any pending\nqueries. This is a direct implementation of &quot;Example 2: Online Backup\nof a Running Database&quot; from [SQLite&#39;s Online Backup API\ndocumentation](https://www.sqlite.org/backup.html).",45,{"inputs":[{"name":"backup"},{"name":"c_int"},{"name":"duration"},{"name":"option"}],"output":{"name":"result"}}],[11,"drop","","",45,{"inputs":[{"name":"backup"}],"output":null}],[0,"functions","rusqlite","Create or redefine SQL functions.",null,null],[6,"sqlite3_context","rusqlite::functions","",null,null],[6,"sqlite3_value","","",null,null],[5,"sqlite3_value_type","","",null,null],[5,"sqlite3_value_numeric_type","","",null,null],[3,"Context","","Context is a wrapper for the SQLite function evaluation context.",null,null],[8,"ToResult","","A trait for types that can be converted into the result of an SQL function.",null,null],[10,"set_result","","",46,null],[8,"FromValue","","A trait for types that can be created from a SQLite function parameter value.",null,null],[10,"parameter_value","","",47,null],[11,"parameter_has_valid_sqlite_type","","FromValue types can implement this method and use sqlite3_value_type to check that\nthe type reported by SQLite matches a type suitable for Self. This method is used\nby `Context::get` to confirm that the parameter contains a valid type before\nattempting to retrieve the value.",47,null],[8,"Aggregate","","Aggregate is the callback interface for user-defined aggregate function.",null,null],[10,"init","","Initializes the aggregation context. Will be called prior to the first call\nto `step()` to set up the context for an invocation of the function. (Note:\n`init()` will not be called if the there are no rows.)",48,{"inputs":[{"name":"aggregate"}],"output":{"name":"a"}}],[10,"step","","&quot;step&quot; function called once for each row in an aggregate group. May be called\n0 times if there are no rows.",48,{"inputs":[{"name":"aggregate"},{"name":"context"},{"name":"a"}],"output":{"name":"result"}}],[10,"finalize","","Computes and returns the final result. Will be called exactly once for each\ninvocation of the function. If `step()` was called at least once, will be given\n`Some(A)` (the same `A` as was created by `init` and given to `step`); if `step()`\nwas not called (because the function is running against 0 rows), will be given\n`None`.",48,{"inputs":[{"name":"aggregate"},{"name":"option"}],"output":{"name":"result"}}],[11,"set_result","","",32,null],[11,"set_result","","",33,null],[11,"set_result","collections::string","",34,null],[11,"set_result","collections::vec","",35,null],[11,"set_result","core::option","",36,null],[11,"set_result","rusqlite::types","",37,null],[11,"parameter_value","rusqlite::functions","",32,null],[11,"parameter_has_valid_sqlite_type","","",32,null],[11,"parameter_value","","",33,null],[11,"parameter_has_valid_sqlite_type","","",33,null],[11,"parameter_value","collections::string","",34,null],[11,"parameter_has_valid_sqlite_type","","",34,null],[11,"parameter_value","collections::vec","",35,null],[11,"parameter_has_valid_sqlite_type","","",35,null],[11,"parameter_value","core::option","",36,null],[11,"parameter_has_valid_sqlite_type","","",36,null],[11,"len","rusqlite::functions","Returns the number of arguments to the function.",49,{"inputs":[{"name":"context"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns `true` when there is no argument.",49,{"inputs":[{"name":"context"}],"output":{"name":"bool"}}],[11,"get","","Returns the `idx`th argument as a `T`.",49,{"inputs":[{"name":"context"},{"name":"usize"}],"output":{"name":"result"}}],[11,"set_aux","","Sets the auxilliary data associated with a particular parameter. See\nhttps://www.sqlite.org/c3ref/get_auxdata.html for a discussion of\nthis feature, or the unit tests of this module for an example.",49,{"inputs":[{"name":"context"},{"name":"c_int"},{"name":"t"}],"output":null}],[11,"get_aux","","Gets the auxilliary data that was associated with a given parameter\nvia `set_aux`. Returns `None` if no data has been associated.",49,{"inputs":[{"name":"context"},{"name":"c_int"}],"output":{"name":"option"}}],[11,"create_scalar_function","rusqlite","Attach a user-defined scalar function to this database connection.",39,{"inputs":[{"name":"connection"},{"name":"str"},{"name":"c_int"},{"name":"bool"},{"name":"f"}],"output":{"name":"result"}}],[11,"create_aggregate_function","","Attach a user-defined aggregate function to this database connection.",39,{"inputs":[{"name":"connection"},{"name":"str"},{"name":"c_int"},{"name":"bool"},{"name":"d"}],"output":{"name":"result"}}],[11,"remove_function","","Removes a user-defined function from this database connection.",39,{"inputs":[{"name":"connection"},{"name":"str"},{"name":"c_int"}],"output":{"name":"result"}}],[0,"blob","","Incremental BLOB I/O.",null,null],[3,"Blob","rusqlite::blob","Handle to an open BLOB.",null,null],[3,"ZeroBlob","","BLOB of length N that is filled with zeroes.",null,null],[12,"0","","",50,null],[11,"blob_open","rusqlite","Open a handle to the BLOB located in `row`, `column`, `table` in database `db`.",39,{"inputs":[{"name":"connection"},{"name":"databasename"},{"name":"str"},{"name":"str"},{"name":"i64"},{"name":"bool"}],"output":{"name":"result"}}],[11,"reopen","rusqlite::blob","Move a BLOB handle to a new row.",51,{"inputs":[{"name":"blob"},{"name":"i64"}],"output":{"name":"result"}}],[11,"size","","Return the size in bytes of the BLOB.",51,{"inputs":[{"name":"blob"}],"output":{"name":"i32"}}],[11,"close","","Close a BLOB handle.",51,{"inputs":[{"name":"blob"}],"output":{"name":"result"}}],[11,"read","","Read data from a BLOB incrementally. Will return Ok(0) if the end of the blob\nhas been reached.",51,null],[11,"write","","Write data into a BLOB incrementally. Will return `Ok(0)` if the end of the blob\nhas been reached; consider using `Write::write_all(buf)` if you want to get an\nerror if the entirety of the buffer cannot be written.",51,null],[11,"flush","","",51,{"inputs":[{"name":"blob"}],"output":{"name":"result"}}],[11,"seek","","Seek to an offset, in bytes, in BLOB.",51,{"inputs":[{"name":"blob"},{"name":"seekfrom"}],"output":{"name":"result"}}],[11,"drop","","",51,{"inputs":[{"name":"blob"}],"output":null}],[11,"clone","","",50,{"inputs":[{"name":"zeroblob"}],"output":{"name":"zeroblob"}}],[11,"bind_parameter","","",50,null],[6,"SqliteTransaction","rusqlite","Old name for `Transaction`. `SqliteTransaction` is deprecated.",null,null],[6,"SqliteError","","Old name for `Error`. `SqliteError` is deprecated.",null,null],[6,"SqliteLoadExtensionGuard","","Old name for `LoadExtensionGuard`. `SqliteLoadExtensionGuard` is deprecated.",null,null],[6,"SqliteResult","","Old name for `Result`. `SqliteResult` is deprecated.",null,null],[6,"Result","","A typedef of the result returned by many methods.",null,null],[6,"SqliteConnection","","Old name for `Connection`. `SqliteConnection` is deprecated.",null,null],[6,"SqliteOpenFlags","","Old name for `OpenFlags`. `SqliteOpenFlags` is deprecated.",null,null],[6,"SqliteStatement","","Old name for `Statement`. `SqliteStatement` is deprecated.",null,null],[6,"SqliteRows","","Old name for `Rows`. `SqliteRows` is deprecated.",null,null],[6,"SqliteRow","","Old name for `Row`. `SqliteRow` is deprecated.",null,null],[17,"SQLITE_OPEN_READ_ONLY","","",null,null],[17,"SQLITE_OPEN_READ_WRITE","","",null,null],[17,"SQLITE_OPEN_CREATE","","",null,null],[17,"SQLITE_OPEN_URI","","",null,null],[17,"SQLITE_OPEN_MEMORY","","",null,null],[17,"SQLITE_OPEN_NO_MUTEX","","",null,null],[17,"SQLITE_OPEN_FULL_MUTEX","","",null,null],[17,"SQLITE_OPEN_SHARED_CACHE","","",null,null],[17,"SQLITE_OPEN_PRIVATE_CACHE","","",null,null],[8,"RowIndex","","A trait implemented by types that can index into columns of a row.",null,null],[10,"idx","","Returns the index of the appropriate column, or `None` if no such\ncolumn exists.",52,{"inputs":[{"name":"rowindex"},{"name":"statement"}],"output":{"name":"result"}}],[11,"open","","Open a new connection to a SQLite database.",39,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"open_in_memory","","Open a new connection to an in-memory SQLite database.",39,{"inputs":[],"output":{"name":"result"}}],[11,"open_with_flags","","Open a new connection to a SQLite database.",39,{"inputs":[{"name":"p"},{"name":"openflags"}],"output":{"name":"result"}}],[11,"open_in_memory_with_flags","","Open a new connection to an in-memory SQLite database.",39,{"inputs":[{"name":"openflags"}],"output":{"name":"result"}}],[11,"execute_batch","","Convenience method to run multiple SQL statements (that cannot take any parameters).",39,{"inputs":[{"name":"connection"},{"name":"str"}],"output":{"name":"result"}}],[11,"execute","","Convenience method to prepare and execute a single SQL statement.",39,null],[11,"last_insert_rowid","","Get the SQLite rowid of the most recent successful INSERT.",39,{"inputs":[{"name":"connection"}],"output":{"name":"i64"}}],[11,"query_row","","Convenience method to execute a query that is expected to return a single row.",39,null],[11,"query_row_and_then","","Convenience method to execute a query that is expected to return a single row,\nand execute a mapping via `f` on that returned row with the possibility of failure.\nThe `Result` type of `f` must implement `std::convert::From&lt;Error&gt;`.",39,null],[11,"query_row_safe","","Convenience method to execute a query that is expected to return a single row.",39,null],[11,"prepare","","Prepare a SQL statement for execution.",39,{"inputs":[{"name":"connection"},{"name":"str"}],"output":{"name":"result"}}],[11,"close","","Close the SQLite connection.",39,{"inputs":[{"name":"connection"}],"output":{"name":"result"}}],[11,"load_extension_enable","","Enable loading of SQLite extensions. Strongly consider using `LoadExtensionGuard`\ninstead of this function.",39,{"inputs":[{"name":"connection"}],"output":{"name":"result"}}],[11,"load_extension_disable","","Disable loading of SQLite extensions.",39,{"inputs":[{"name":"connection"}],"output":{"name":"result"}}],[11,"load_extension","","Load the SQLite extension at `dylib_path`. `dylib_path` is passed through to\n`sqlite3_load_extension`, which may attempt OS-specific modifications if the file\ncannot be loaded directly.",39,{"inputs":[{"name":"connection"},{"name":"p"},{"name":"option"}],"output":{"name":"result"}}],[11,"handle","","Get access to the underlying SQLite database connection handle.",39,null],[11,"fmt","","",39,{"inputs":[{"name":"connection"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",53,null],[11,"cmp","","",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"option"}}],[11,"lt","","",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"le","","",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"gt","","",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"ge","","",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"clone","","",53,{"inputs":[{"name":"openflags"}],"output":{"name":"openflags"}}],[11,"eq","","",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"ne","","",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"fmt","","",53,{"inputs":[{"name":"openflags"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",53,{"inputs":[],"output":{"name":"openflags"}}],[11,"all","","Returns the set containing all flags.",53,{"inputs":[],"output":{"name":"openflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",53,{"inputs":[{"name":"openflags"}],"output":{"name":"c_int"}}],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",53,{"inputs":[{"name":"c_int"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",53,{"inputs":[{"name":"c_int"}],"output":{"name":"openflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",53,{"inputs":[{"name":"openflags"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",53,{"inputs":[{"name":"openflags"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"openflags"}}],[11,"bitor_assign","","Adds the set of flags.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"openflags"}}],[11,"bitxor_assign","","Toggles the set of flags.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"openflags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":{"name":"openflags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",53,{"inputs":[{"name":"openflags"},{"name":"openflags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",53,{"inputs":[{"name":"openflags"}],"output":{"name":"openflags"}}],[11,"extend","","",53,{"inputs":[{"name":"openflags"},{"name":"t"}],"output":null}],[11,"from_iter","","",53,{"inputs":[{"name":"t"}],"output":{"name":"openflags"}}],[11,"default","","",53,{"inputs":[],"output":{"name":"openflags"}}],[11,"column_names","","Get all the column names in the result set of the prepared statement.",41,{"inputs":[{"name":"statement"}],"output":{"name":"vec"}}],[11,"column_count","","Return the number of columns in the result set returned by the prepared statement.",41,{"inputs":[{"name":"statement"}],"output":{"name":"i32"}}],[11,"column_index","","Returns the column index in the result set for a given column name.",41,{"inputs":[{"name":"statement"},{"name":"str"}],"output":{"name":"result"}}],[11,"execute","","Execute the prepared statement.",41,null],[11,"query","","Execute the prepared statement, returning a handle to the resulting rows.",41,null],[11,"query_map","","Executes the prepared statement and maps a function over the resulting rows, returning\nan iterator over the mapped function results.",41,null],[11,"query_and_then","","Executes the prepared statement and maps a function over the resulting\nrows, where the function returns a `Result` with `Error` type implementing\n`std::convert::From&lt;Error&gt;` (so errors can be unified).",41,null],[11,"finalize","","Consumes the statement.",41,{"inputs":[{"name":"statement"}],"output":{"name":"result"}}],[11,"into","","",41,{"inputs":[{"name":"statement"}],"output":{"name":"rawstatement"}}],[11,"fmt","","",41,{"inputs":[{"name":"statement"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"drop","","",41,{"inputs":[{"name":"statement"}],"output":null}],[11,"next","","",54,{"inputs":[{"name":"mappedrows"}],"output":{"name":"option"}}],[11,"next","","",55,{"inputs":[{"name":"andthenrows"}],"output":{"name":"option"}}],[11,"next","","Attempt to get the next row from the query. Returns `Some(Ok(Row))` if there\nis another row, `Some(Err(...))` if there was an error getting the next\nrow, and `None` if all rows have been retrieved.",56,{"inputs":[{"name":"rows"}],"output":{"name":"option"}}],[11,"drop","","",56,{"inputs":[{"name":"rows"}],"output":null}],[11,"get","","Get the value of a particular column of the result row.",57,{"inputs":[{"name":"row"},{"name":"i"}],"output":{"name":"t"}}],[11,"get_checked","","Get the value of a particular column of the result row.",57,{"inputs":[{"name":"row"},{"name":"i"}],"output":{"name":"result"}}],[11,"column_count","","Return the number of columns in the current row.",57,{"inputs":[{"name":"row"}],"output":{"name":"i32"}}]],"paths":[[4,"TransactionBehavior"],[4,"Error"],[4,"DatabaseName"],[3,"Struct_sqlite3_file"],[3,"Struct_sqlite3_io_methods"],[3,"Struct_sqlite3_vfs"],[3,"Struct_sqlite3_mem_methods"],[3,"Struct_sqlite3_module"],[3,"Struct_sqlite3_index_info"],[3,"Struct_sqlite3_index_constraint"],[3,"Struct_sqlite3_index_orderby"],[3,"Struct_sqlite3_index_constraint_usage"],[3,"Struct_sqlite3_vtab"],[3,"Struct_sqlite3_vtab_cursor"],[3,"Struct_sqlite3_mutex_methods"],[3,"Struct_sqlite3_pcache_page"],[3,"Struct_sqlite3_pcache_methods2"],[3,"Struct_sqlite3_pcache_methods"],[3,"Struct_sqlite3_rtree_geometry"],[3,"Struct_sqlite3_rtree_query_info"],[3,"Struct___va_list_tag"],[4,"ErrorCode"],[3,"Error"],[4,"Value"],[3,"Timespec"],[3,"NaiveDate"],[3,"NaiveTime"],[3,"NaiveDateTime"],[3,"DateTime"],[4,"Value"],[8,"ToSql"],[8,"FromSql"],[6,"c_int"],[6,"c_double"],[3,"String"],[3,"Vec"],[4,"Option"],[3,"Null"],[3,"Transaction"],[3,"Connection"],[3,"CachedStatement"],[3,"Statement"],[3,"LoadExtensionGuard"],[3,"Progress"],[4,"StepResult"],[3,"Backup"],[8,"ToResult"],[8,"FromValue"],[8,"Aggregate"],[3,"Context"],[3,"ZeroBlob"],[3,"Blob"],[8,"RowIndex"],[3,"OpenFlags"],[3,"MappedRows"],[3,"AndThenRows"],[3,"Rows"],[3,"Row"]]};
initSearch(searchIndex);
