var searchIndex = {};
searchIndex["rusqlite"] = {"doc":"Rusqlite is an ergonomic wrapper for using SQLite from Rust. It attempts to expose an interface similar to rust-postgres.","items":[[3,"Savepoint","rusqlite","Represents a savepoint on a database connection.",null,null],[3,"Transaction","","Represents a transaction on a database connection.",null,null],[3,"CachedStatement","","Cacheable statement.",null,null],[3,"LoadExtensionGuard","","RAII guard temporarily enabling SQLite extensions to be loaded.",null,null],[3,"Connection","","A connection to a SQLite database.",null,null],[3,"OpenFlags","","Flags for opening SQLite database connections. See sqlite3_open_v2 for details.",null,null],[3,"Statement","","A prepared statement.",null,null],[3,"MappedRows","","An iterator over the mapped resulting rows of a query.",null,null],[3,"AndThenRows","","An iterator over the mapped resulting rows of a query, with an Error type unifying with Error.",null,null],[3,"Rows","","An handle for the resulting rows of a query.",null,null],[3,"Row","","A single result row of a query.",null,null],[4,"DropBehavior","","Options for how a Transaction or Savepoint should behave when it is dropped.",null,null],[13,"Rollback","","Roll back the changes. This is the default.",0,null],[13,"Commit","","Commit the changes.",0,null],[13,"Ignore","","Do not commit or roll back changes - this will leave the transaction or savepoint open, so should be used with care.",0,null],[4,"TransactionBehavior","","Options for transaction behavior. See BEGIN TRANSACTION for details.",null,null],[13,"Deferred","","",1,null],[13,"Immediate","","",1,null],[13,"Exclusive","","",1,null],[4,"Error","","Enum listing possible errors from rusqlite.",null,null],[13,"SqliteFailure","","An error from an underlying SQLite call.",2,null],[13,"SqliteSingleThreadedMode","","Error reported when attempting to open a connection when SQLite was configured to allow single-threaded use only.",2,null],[13,"FromSqlConversionFailure","","Error when the value of a particular column is requested, but it cannot be converted to the requested Rust type.",2,null],[13,"IntegralValueOutOfRange","","Error when SQLite gives us an integral value outside the range of the requested type (e.g., trying to get the value 1000 into a `u8`).  The associated `c_int` is the column index, and the associated `i64` is the value returned by SQLite.",2,null],[13,"Utf8Error","","Error converting a string to UTF-8.",2,null],[13,"NulError","","Error converting a string to a C-compatible string because it contained an embedded nul.",2,null],[13,"InvalidParameterName","","Error when using SQL named parameters and passing a parameter name not present in the SQL.",2,null],[13,"InvalidPath","","Error converting a file path to a string.",2,null],[13,"ExecuteReturnedResults","","Error returned when an `execute` call returns rows.",2,null],[13,"QueryReturnedNoRows","","Error when a query that was expected to return at least one row (e.g., for `query_row`) did not return any.",2,null],[13,"InvalidColumnIndex","","Error when the value of a particular column is requested, but the index is out of range for the statement.",2,null],[13,"InvalidColumnName","","Error when the value of a named column is requested, but no column matches the name for the statement.",2,null],[13,"InvalidColumnType","","Error when the value of a particular column is requested, but the type of the result in that column cannot be converted to the requested Rust type.",2,null],[13,"StatementChangedRows","","Error when a query that was expected to insert one row did not insert any or insert many.",2,null],[13,"InvalidFunctionParameterType","","Error returned by `functions::Context::get` when the function argument cannot be converted to the requested type.",2,null],[13,"UserFunctionError","","An error case available for implementors of custom user functions (e.g., `create_scalar_function`).",2,null],[4,"DatabaseName","","Name for a database within a SQLite connection.",null,null],[13,"Main","","The main database.",3,null],[13,"Temp","","The temporary database (e.g., any \"CREATE TEMPORARY TABLE\" tables).",3,null],[13,"Attached","","A database that has been attached via \"ATTACH DATABASE ...\".",3,null],[0,"types","","Traits dealing with SQLite data types.",null,null],[3,"Null","rusqlite::types","Empty struct that can be used to fill in a query parameter as `NULL`.",null,null],[4,"FromSqlError","","Enum listing possible errors from `FromSql` trait.",null,null],[13,"InvalidType","","Error when an SQLite value is requested, but the type of the result cannot be converted to the requested Rust type.",4,null],[13,"OutOfRange","","Error when the i64 value returned by SQLite cannot be stored into the requested type.",4,null],[13,"Other","","An error case available for implementors of the `FromSql` trait.",4,null],[4,"ToSqlOutput","","`ToSqlOutput` represents the possible output types for implementors of the `ToSql` trait.",null,null],[13,"Borrowed","","A borrowed SQLite-representable value.",5,null],[13,"Owned","","An owned SQLite-representable value.",5,null],[13,"ZeroBlob","","A BLOB of the given length that is filled with zeroes.",5,null],[4,"Value","","Owning dynamic type value. Value's type is typically dictated by SQLite (not by the caller).",null,null],[13,"Null","","The value is a `NULL` value.",6,null],[13,"Integer","","The value is a signed integer.",6,null],[13,"Real","","The value is a floating point number.",6,null],[13,"Text","","The value is a text string.",6,null],[13,"Blob","","The value is a blob of data",6,null],[4,"ValueRef","","A non-owning dynamic type value. Typically the memory backing this value is owned by SQLite.",null,null],[13,"Null","","The value is a `NULL` value.",7,null],[13,"Integer","","The value is a signed integer.",7,null],[13,"Real","","The value is a floating point number.",7,null],[13,"Text","","The value is a text string.",7,null],[13,"Blob","","The value is a blob of data",7,null],[4,"Type","","",null,null],[13,"Null","","",8,null],[13,"Integer","","",8,null],[13,"Real","","",8,null],[13,"Text","","",8,null],[13,"Blob","","",8,null],[11,"clone","","",6,{"inputs":[{"name":"self"}],"output":{"name":"value"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"self"},{"name":"value"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"self"},{"name":"value"}],"output":{"name":"bool"}}],[11,"from","","",6,{"inputs":[{"name":"null"}],"output":{"name":"value"}}],[11,"from","","",6,{"inputs":[{"name":"bool"}],"output":{"name":"value"}}],[11,"from","","",6,{"inputs":[{"name":"i8"}],"output":{"name":"value"}}],[11,"from","","",6,{"inputs":[{"name":"i16"}],"output":{"name":"value"}}],[11,"from","","",6,{"inputs":[{"name":"i32"}],"output":{"name":"value"}}],[11,"from","","",6,{"inputs":[{"name":"u8"}],"output":{"name":"value"}}],[11,"from","","",6,{"inputs":[{"name":"u16"}],"output":{"name":"value"}}],[11,"from","","",6,{"inputs":[{"name":"u32"}],"output":{"name":"value"}}],[11,"from","","",6,{"inputs":[{"name":"i64"}],"output":{"name":"value"}}],[11,"from","","",6,{"inputs":[{"name":"f64"}],"output":{"name":"value"}}],[11,"from","","",6,{"inputs":[{"name":"string"}],"output":{"name":"value"}}],[11,"from","","",6,{"inputs":[{"name":"vec"}],"output":{"name":"value"}}],[11,"data_type","","",6,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"clone","","",7,{"inputs":[{"name":"self"}],"output":{"name":"valueref"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",7,{"inputs":[{"name":"self"},{"name":"valueref"}],"output":{"name":"bool"}}],[11,"ne","","",7,{"inputs":[{"name":"self"},{"name":"valueref"}],"output":{"name":"bool"}}],[11,"data_type","","",7,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"as_i64","","If `self` is case `Integer`, returns the integral value. Otherwise, returns `Err(Error::InvalidColumnType)`.",7,{"inputs":[{"name":"self"}],"output":{"name":"fromsqlresult"}}],[11,"as_f64","","If `self` is case `Real`, returns the floating point value. Otherwise, returns `Err(Error::InvalidColumnType)`.",7,{"inputs":[{"name":"self"}],"output":{"name":"fromsqlresult"}}],[11,"as_str","","If `self` is case `Text`, returns the string value. Otherwise, returns `Err(Error::InvalidColumnType)`.",7,{"inputs":[{"name":"self"}],"output":{"name":"fromsqlresult"}}],[11,"as_blob","","If `self` is case `Blob`, returns the byte slice. Otherwise, returns `Err(Error::InvalidColumnType)`.",7,{"inputs":[{"name":"self"}],"output":{"name":"fromsqlresult"}}],[11,"from","","",6,{"inputs":[{"name":"valueref"}],"output":{"name":"value"}}],[11,"from","","",7,{"inputs":[{"name":"str"}],"output":{"name":"valueref"}}],[11,"from","","",7,null],[11,"from","","",7,{"inputs":[{"name":"value"}],"output":{"name":"valueref"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",4,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"column_result","","",6,{"inputs":[{"name":"valueref"}],"output":{"name":"fromsqlresult"}}],[11,"from","","",5,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"from","","",5,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"to_sql","","",5,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"to_sql","","",9,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"to_sql","","",6,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[6,"FromSqlResult","","Result type for implementors of the `FromSql` trait.",null,null],[8,"FromSql","","A trait for types that can be created from a SQLite value.",null,null],[10,"column_result","","",10,{"inputs":[{"name":"valueref"}],"output":{"name":"fromsqlresult"}}],[8,"ToSql","","A trait for types that can be converted into SQLite values.",null,null],[10,"to_sql","","",11,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"clone","","",9,{"inputs":[{"name":"self"}],"output":{"name":"null"}}],[11,"clone","","",8,{"inputs":[{"name":"self"}],"output":{"name":"type"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",8,{"inputs":[{"name":"self"},{"name":"type"}],"output":{"name":"bool"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","rusqlite","",1,{"inputs":[{"name":"self"}],"output":{"name":"transactionbehavior"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"dropbehavior"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"dropbehavior"}],"output":{"name":"bool"}}],[11,"new","","Begin a new transaction. Cannot be nested; see `savepoint` for nested transactions.",12,{"inputs":[{"name":"connection"},{"name":"transactionbehavior"}],"output":{"name":"result"}}],[11,"savepoint","","Starts a new savepoint, allowing nested transactions.",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"savepoint_with_name","","Create a new savepoint with a custom savepoint name. See `savepoint()`.",12,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"drop_behavior","","Get the current setting for what happens to the transaction when it is dropped.",12,{"inputs":[{"name":"self"}],"output":{"name":"dropbehavior"}}],[11,"set_drop_behavior","","Configure the transaction to perform the specified action when it is dropped.",12,{"inputs":[{"name":"self"},{"name":"dropbehavior"}],"output":null}],[11,"commit","","A convenience method which consumes and commits a transaction.",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"rollback","","A convenience method which consumes and rolls back a transaction.",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"finish","","Consumes the transaction, committing or rolling back according to the current setting (see `drop_behavior`).",12,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"deref","","",12,{"inputs":[{"name":"self"}],"output":{"name":"connection"}}],[11,"drop","","",12,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Begin a new savepoint. Can be nested.",13,{"inputs":[{"name":"connection"}],"output":{"name":"result"}}],[11,"with_name","","Begin a new savepoint with a user-provided savepoint name.",13,{"inputs":[{"name":"connection"},{"name":"t"}],"output":{"name":"result"}}],[11,"savepoint","","Begin a nested savepoint.",13,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"savepoint_with_name","","Begin a nested savepoint with a user-provided savepoint name.",13,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"drop_behavior","","Get the current setting for what happens to the savepoint when it is dropped.",13,{"inputs":[{"name":"self"}],"output":{"name":"dropbehavior"}}],[11,"set_drop_behavior","","Configure the savepoint to perform the specified action when it is dropped.",13,{"inputs":[{"name":"self"},{"name":"dropbehavior"}],"output":null}],[11,"commit","","A convenience method which consumes and commits a savepoint.",13,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"rollback","","A convenience method which rolls back a savepoint.",13,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"finish","","Consumes the savepoint, committing or rolling back according to the current setting (see `drop_behavior`).",13,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"deref","","",13,{"inputs":[{"name":"self"}],"output":{"name":"connection"}}],[11,"drop","","",13,{"inputs":[{"name":"self"}],"output":null}],[11,"transaction","","Begin a new transaction with the default behavior (DEFERRED).",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"transaction_with_behavior","","Begin a new transaction with a specified behavior.",14,{"inputs":[{"name":"self"},{"name":"transactionbehavior"}],"output":{"name":"result"}}],[11,"savepoint","","Begin a new savepoint with the default behavior (DEFERRED).",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"savepoint_with_name","","Begin a new savepoint with a specified name.",14,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"result"}}],[11,"prepare_cached","","Prepare a SQL statement for execution, returning a previously prepared (but not currently in-use) statement if one is available. The returned statement will be cached for reuse by future calls to `prepare_cached` once it is dropped.",14,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"set_prepared_statement_cache_capacity","","Set the maximum number of cached prepared statements this connection will hold. By default, a connection will hold a relatively small number of cached statements. If you need more, or know that you will not use cached statements, you can set the capacity manually using this method.",14,{"inputs":[{"name":"self"},{"name":"usize"}],"output":null}],[11,"flush_prepared_statement_cache","","",14,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",15,{"inputs":[{"name":"self"}],"output":{"name":"statement"}}],[11,"deref_mut","","",15,{"inputs":[{"name":"self"}],"output":{"name":"statement"}}],[11,"drop","","",15,{"inputs":[{"name":"self"}],"output":null}],[11,"discard","","Discard the statement, preventing it from being returned to its `Connection`'s collection of cached statements.",15,{"inputs":[{"name":"self"}],"output":null}],[11,"execute_named","","Convenience method to prepare and execute a single SQL statement with named parameter(s).",14,null],[11,"query_row_named","","Convenience method to execute a query with named parameter(s) that is expected to return a single row.",14,null],[11,"parameter_index","","Return the index of an SQL parameter given its name.",16,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"execute_named","","Execute the prepared statement with named parameter(s). If any parameters that were in the prepared statement are not included in `params`, they will continue to use the most-recently bound value from a previous call to `execute_named`, or `NULL` if they have never been bound.",16,null],[11,"query_named","","Execute the prepared statement with named parameter(s), returning a handle for the resulting rows. If any parameters that were in the prepared statement are not included in `params`, they will continue to use the most-recently bound value from a previous call to `query_named`, or `NULL` if they have never been bound.",16,null],[11,"query_map_named","","Execute the prepared statement with named parameter(s), returning an iterator over the result of calling the mapping function over the query's rows. If any parameters that were in the prepared statement are not included in `params`, they will continue to use the most-recently bound value from a previous call to `query_named`, or `NULL` if they have never been bound.",16,null],[11,"query_and_then_named","","Execute the prepared statement with named parameter(s), returning an iterator over the result of calling the mapping function over the query's rows. If any parameters that were in the prepared statement are not included in `params`, they will continue to use the most-recently bound value from a previous call to `query_named`, or `NULL` if they have never been bound.",16,null],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",2,{"inputs":[{"name":"utf8error"}],"output":{"name":"error"}}],[11,"from","","",2,{"inputs":[{"name":"nulerror"}],"output":{"name":"error"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",2,{"inputs":[{"name":"self"}],"output":{"name":"str"}}],[11,"cause","","",2,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"insert","","Execute an INSERT and return the ROWID.",16,null],[11,"exists","","Return `true` if a query in the SQL statement it executes returns one or more rows and `false` if the SQL returns an empty set.",16,null],[11,"query_row","","Convenience method to execute a query that is expected to return a single row.",16,null],[11,"new","","Attempt to enable loading extensions. Loading extensions will be disabled when this guard goes out of scope. Cannot be meaningfully nested.",17,{"inputs":[{"name":"connection"}],"output":{"name":"result"}}],[11,"drop","","",17,{"inputs":[{"name":"self"}],"output":null}],[0,"trace","","Tracing and profiling functions. Error and warning log.",null,null],[5,"config_log","rusqlite::trace","Set up the process-wide SQLite error logging callback. This function is marked unsafe for two reasons:",null,{"inputs":[{"name":"option"}],"output":{"name":"result"}}],[5,"log","","Write a message into the error log established by `config_log`.",null,{"inputs":[{"name":"c_int"},{"name":"str"}],"output":null}],[11,"trace","rusqlite","Register or clear a callback function that can be used for tracing the execution of SQL statements.",14,{"inputs":[{"name":"self"},{"name":"option"}],"output":null}],[11,"profile","","Register or clear a callback function that can be used for profiling the execution of SQL statements.",14,{"inputs":[{"name":"self"},{"name":"option"}],"output":null}],[0,"backup","","Online SQLite backup API.",null,null],[3,"Progress","rusqlite::backup","Struct specifying the progress of a backup. The percentage completion can be calculated as `(pagecount - remaining) / pagecount`. The progress of a backup is as of the last call to `step` - if the source database is modified after a call to `step`, the progress value will become outdated and potentially incorrect.",null,null],[12,"remaining","","Number of pages in the source database that still need to be backed up.",18,null],[12,"pagecount","","Total number of pages in the source database.",18,null],[3,"Backup","","A handle to an online backup.",null,null],[4,"StepResult","","Possible successful results of calling `Backup::step`.",null,null],[13,"Done","","The backup is complete.",19,null],[13,"More","","The step was successful but there are still more pages that need to be backed up.",19,null],[13,"Busy","","The step failed because appropriate locks could not be aquired. This is not a fatal error - the step can be retried.",19,null],[13,"Locked","","The step failed because the source connection was writing to the database. This is not a fatal error - the step can be retried.",19,null],[11,"backup","rusqlite","Back up the `name` database to the given destination path. If `progress` is not `None`, it will be called periodically until the backup completes.",14,{"inputs":[{"name":"self"},{"name":"databasename"},{"name":"p"},{"name":"option"}],"output":{"name":"result"}}],[11,"restore","","Restore the given source path into the `name` database. If `progress` is not `None`, it will be called periodically until the restore completes.",14,{"inputs":[{"name":"self"},{"name":"databasename"},{"name":"p"},{"name":"option"}],"output":{"name":"result"}}],[11,"clone","rusqlite::backup","",19,{"inputs":[{"name":"self"}],"output":{"name":"stepresult"}}],[11,"fmt","","",19,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",19,{"inputs":[{"name":"self"},{"name":"stepresult"}],"output":{"name":"bool"}}],[11,"clone","","",18,{"inputs":[{"name":"self"}],"output":{"name":"progress"}}],[11,"fmt","","",18,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Attempt to create a new handle that will allow backups from `from` to `to`. Note that `to` is a `&mut` - this is because SQLite forbids any API calls on the destination of a backup while the backup is taking place.",20,{"inputs":[{"name":"connection"},{"name":"connection"}],"output":{"name":"result"}}],[11,"new_with_names","","Attempt to create a new handle that will allow backups from the `from_name` database of `from` to the `to_name` database of `to`. Note that `to` is a `&mut` - this is because SQLite forbids any API calls on the destination of a backup while the backup is taking place.",20,{"inputs":[{"name":"connection"},{"name":"databasename"},{"name":"connection"},{"name":"databasename"}],"output":{"name":"result"}}],[11,"progress","","Gets the progress of the backup as of the last call to `step`.",20,{"inputs":[{"name":"self"}],"output":{"name":"progress"}}],[11,"step","","Attempts to back up the given number of pages. If `num_pages` is negative, will attempt to back up all remaining pages. This will hold a lock on the source database for the duration, so it is probably not what you want for databases that are currently active (see `run_to_completion` for a better alternative).",20,{"inputs":[{"name":"self"},{"name":"c_int"}],"output":{"name":"result"}}],[11,"run_to_completion","","Attempts to run the entire backup. Will call `step(pages_per_step)` as many times as necessary, sleeping for `pause_between_pages` between each call to give the source database time to process any pending queries. This is a direct implementation of \"Example 2: Online Backup of a Running Database\" from SQLite's Online Backup API documentation.",20,{"inputs":[{"name":"self"},{"name":"c_int"},{"name":"duration"},{"name":"option"}],"output":{"name":"result"}}],[11,"drop","","",20,{"inputs":[{"name":"self"}],"output":null}],[0,"functions","rusqlite","Create or redefine SQL functions.",null,null],[3,"Context","rusqlite::functions","Context is a wrapper for the SQLite function evaluation context.",null,null],[8,"Aggregate","","Aggregate is the callback interface for user-defined aggregate function.",null,null],[10,"init","","Initializes the aggregation context. Will be called prior to the first call to `step()` to set up the context for an invocation of the function. (Note: `init()` will not be called if the there are no rows.)",21,{"inputs":[{"name":"self"}],"output":{"name":"a"}}],[10,"step","","\"step\" function called once for each row in an aggregate group. May be called 0 times if there are no rows.",21,{"inputs":[{"name":"self"},{"name":"context"},{"name":"a"}],"output":{"name":"result"}}],[10,"finalize","","Computes and returns the final result. Will be called exactly once for each invocation of the function. If `step()` was called at least once, will be given `Some(A)` (the same `A` as was created by `init` and given to `step`); if `step()` was not called (because the function is running against 0 rows), will be given `None`.",21,{"inputs":[{"name":"self"},{"name":"option"}],"output":{"name":"result"}}],[11,"len","","Returns the number of arguments to the function.",22,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns `true` when there is no argument.",22,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"get","","Returns the `idx`th argument as a `T`.",22,{"inputs":[{"name":"self"},{"name":"usize"}],"output":{"name":"result"}}],[11,"set_aux","","Sets the auxilliary data associated with a particular parameter. See https://www.sqlite.org/c3ref/get_auxdata.html for a discussion of this feature, or the unit tests of this module for an example.",22,{"inputs":[{"name":"self"},{"name":"c_int"},{"name":"t"}],"output":null}],[11,"get_aux","","Gets the auxilliary data that was associated with a given parameter via `set_aux`. Returns `None` if no data has been associated.",22,{"inputs":[{"name":"self"},{"name":"c_int"}],"output":{"name":"option"}}],[11,"create_scalar_function","rusqlite","Attach a user-defined scalar function to this database connection.",14,{"inputs":[{"name":"self"},{"name":"str"},{"name":"c_int"},{"name":"bool"},{"name":"f"}],"output":{"name":"result"}}],[11,"create_aggregate_function","","Attach a user-defined aggregate function to this database connection.",14,{"inputs":[{"name":"self"},{"name":"str"},{"name":"c_int"},{"name":"bool"},{"name":"d"}],"output":{"name":"result"}}],[11,"remove_function","","Removes a user-defined function from this database connection.",14,{"inputs":[{"name":"self"},{"name":"str"},{"name":"c_int"}],"output":{"name":"result"}}],[0,"blob","","Incremental BLOB I/O.",null,null],[3,"Blob","rusqlite::blob","Handle to an open BLOB.",null,null],[3,"ZeroBlob","","BLOB of length N that is filled with zeroes.",null,null],[12,"0","","",23,null],[11,"blob_open","rusqlite","Open a handle to the BLOB located in `row`, `column`, `table` in database `db`.",14,{"inputs":[{"name":"self"},{"name":"databasename"},{"name":"str"},{"name":"str"},{"name":"i64"},{"name":"bool"}],"output":{"name":"result"}}],[11,"reopen","rusqlite::blob","Move a BLOB handle to a new row.",24,{"inputs":[{"name":"self"},{"name":"i64"}],"output":{"name":"result"}}],[11,"size","","Return the size in bytes of the BLOB.",24,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"close","","Close a BLOB handle.",24,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read","","Read data from a BLOB incrementally. Will return Ok(0) if the end of the blob has been reached.",24,null],[11,"write","","Write data into a BLOB incrementally. Will return `Ok(0)` if the end of the blob has been reached; consider using `Write::write_all(buf)` if you want to get an error if the entirety of the buffer cannot be written.",24,null],[11,"flush","","",24,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"seek","","Seek to an offset, in bytes, in BLOB.",24,{"inputs":[{"name":"self"},{"name":"seekfrom"}],"output":{"name":"result"}}],[11,"drop","","",24,{"inputs":[{"name":"self"}],"output":null}],[11,"clone","","",23,{"inputs":[{"name":"self"}],"output":{"name":"zeroblob"}}],[11,"to_sql","","",23,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[6,"SqliteTransaction","rusqlite","Old name for `Transaction`. `SqliteTransaction` is deprecated.",null,null],[6,"SqliteTransactionBehavior","","Old name for `TransactionBehavior`. `SqliteTransactionBehavior` is deprecated.",null,null],[6,"SqliteError","","Old name for `Error`. `SqliteError` is deprecated.",null,null],[6,"SqliteLoadExtensionGuard","","Old name for `LoadExtensionGuard`. `SqliteLoadExtensionGuard` is deprecated.",null,null],[6,"SqliteResult","","Old name for `Result`. `SqliteResult` is deprecated.",null,null],[6,"Result","","A typedef of the result returned by many methods.",null,null],[6,"SqliteConnection","","Old name for `Connection`. `SqliteConnection` is deprecated.",null,null],[6,"SqliteOpenFlags","","Old name for `OpenFlags`. `SqliteOpenFlags` is deprecated.",null,null],[6,"SqliteStatement","","Old name for `Statement`. `SqliteStatement` is deprecated.",null,null],[6,"SqliteRows","","Old name for `Rows`. `SqliteRows` is deprecated.",null,null],[6,"SqliteRow","","Old name for `Row`. `SqliteRow` is deprecated.",null,null],[17,"SQLITE_OPEN_READ_ONLY","","",null,null],[17,"SQLITE_OPEN_READ_WRITE","","",null,null],[17,"SQLITE_OPEN_CREATE","","",null,null],[17,"SQLITE_OPEN_URI","","",null,null],[17,"SQLITE_OPEN_MEMORY","","",null,null],[17,"SQLITE_OPEN_NO_MUTEX","","",null,null],[17,"SQLITE_OPEN_FULL_MUTEX","","",null,null],[17,"SQLITE_OPEN_SHARED_CACHE","","",null,null],[17,"SQLITE_OPEN_PRIVATE_CACHE","","",null,null],[8,"RowIndex","","A trait implemented by types that can index into columns of a row.",null,null],[10,"idx","","Returns the index of the appropriate column, or `None` if no such column exists.",25,{"inputs":[{"name":"self"},{"name":"statement"}],"output":{"name":"result"}}],[11,"open","","Open a new connection to a SQLite database.",14,{"inputs":[{"name":"p"}],"output":{"name":"result"}}],[11,"open_in_memory","","Open a new connection to an in-memory SQLite database.",14,{"inputs":[],"output":{"name":"result"}}],[11,"open_with_flags","","Open a new connection to a SQLite database.",14,{"inputs":[{"name":"p"},{"name":"openflags"}],"output":{"name":"result"}}],[11,"open_in_memory_with_flags","","Open a new connection to an in-memory SQLite database.",14,{"inputs":[{"name":"openflags"}],"output":{"name":"result"}}],[11,"execute_batch","","Convenience method to run multiple SQL statements (that cannot take any parameters).",14,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"execute","","Convenience method to prepare and execute a single SQL statement.",14,null],[11,"last_insert_rowid","","Get the SQLite rowid of the most recent successful INSERT.",14,{"inputs":[{"name":"self"}],"output":{"name":"i64"}}],[11,"query_row","","Convenience method to execute a query that is expected to return a single row.",14,null],[11,"query_row_and_then","","Convenience method to execute a query that is expected to return a single row, and execute a mapping via `f` on that returned row with the possibility of failure. The `Result` type of `f` must implement `std::convert::From<Error>`.",14,null],[11,"query_row_safe","","Convenience method to execute a query that is expected to return a single row.",14,null],[11,"prepare","","Prepare a SQL statement for execution.",14,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"close","","Close the SQLite connection.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"load_extension_enable","","Enable loading of SQLite extensions. Strongly consider using `LoadExtensionGuard` instead of this function.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"load_extension_disable","","Disable loading of SQLite extensions.",14,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"load_extension","","Load the SQLite extension at `dylib_path`. `dylib_path` is passed through to `sqlite3_load_extension`, which may attempt OS-specific modifications if the file cannot be loaded directly.",14,{"inputs":[{"name":"self"},{"name":"p"},{"name":"option"}],"output":{"name":"result"}}],[11,"handle","","Get access to the underlying SQLite database connection handle.",14,null],[11,"fmt","","",14,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"ne","","",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"clone","","",26,{"inputs":[{"name":"self"}],"output":{"name":"openflags"}}],[11,"partial_cmp","","",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"option"}}],[11,"lt","","",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"le","","",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"gt","","",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"ge","","",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"cmp","","",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"ordering"}}],[11,"hash","","",26,null],[11,"fmt","","",26,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"empty","","Returns an empty set of flags.",26,{"inputs":[],"output":{"name":"openflags"}}],[11,"all","","Returns the set containing all flags.",26,{"inputs":[],"output":{"name":"openflags"}}],[11,"bits","","Returns the raw value of the flags currently stored.",26,{"inputs":[{"name":"self"}],"output":{"name":"c_int"}}],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",26,{"inputs":[{"name":"c_int"}],"output":{"name":"option"}}],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",26,{"inputs":[{"name":"c_int"}],"output":{"name":"openflags"}}],[11,"is_empty","","Returns `true` if no flags are currently stored.",26,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_all","","Returns `true` if all flags are currently set.",26,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"bool"}}],[11,"insert","","Inserts the specified flags in-place.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":null}],[11,"remove","","Removes the specified flags in-place.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":null}],[11,"toggle","","Toggles the specified flags in-place.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":null}],[11,"bitor","","Returns the union of the two sets of flags.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"openflags"}}],[11,"bitor_assign","","Adds the set of flags.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":null}],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"openflags"}}],[11,"bitxor_assign","","Toggles the set of flags.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":null}],[11,"bitand","","Returns the intersection between the two sets of flags.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"openflags"}}],[11,"bitand_assign","","Disables all flags disabled in the set.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":null}],[11,"sub","","Returns the set difference of the two sets of flags.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":{"name":"openflags"}}],[11,"sub_assign","","Disables all flags enabled in the set.",26,{"inputs":[{"name":"self"},{"name":"openflags"}],"output":null}],[11,"not","","Returns the complement of this set of flags.",26,{"inputs":[{"name":"self"}],"output":{"name":"openflags"}}],[11,"extend","","",26,{"inputs":[{"name":"self"},{"name":"t"}],"output":null}],[11,"from_iter","","",26,{"inputs":[{"name":"t"}],"output":{"name":"openflags"}}],[11,"default","","",26,{"inputs":[],"output":{"name":"openflags"}}],[11,"column_names","","Get all the column names in the result set of the prepared statement.",16,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"column_count","","Return the number of columns in the result set returned by the prepared statement.",16,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}],[11,"column_index","","Returns the column index in the result set for a given column name.",16,{"inputs":[{"name":"self"},{"name":"str"}],"output":{"name":"result"}}],[11,"execute","","Execute the prepared statement.",16,null],[11,"query","","Execute the prepared statement, returning a handle to the resulting rows.",16,null],[11,"query_map","","Executes the prepared statement and maps a function over the resulting rows, returning an iterator over the mapped function results.",16,null],[11,"query_and_then","","Executes the prepared statement and maps a function over the resulting rows, where the function returns a `Result` with `Error` type implementing `std::convert::From<Error>` (so errors can be unified).",16,null],[11,"finalize","","Consumes the statement.",16,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"into","","",16,{"inputs":[{"name":"self"}],"output":{"name":"rawstatement"}}],[11,"fmt","","",16,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"drop","","",16,{"inputs":[{"name":"self"}],"output":null}],[11,"next","","",27,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","","",28,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","","Attempt to get the next row from the query. Returns `Some(Ok(Row))` if there is another row, `Some(Err(...))` if there was an error getting the next row, and `None` if all rows have been retrieved.",29,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"drop","","",29,{"inputs":[{"name":"self"}],"output":null}],[11,"get","","Get the value of a particular column of the result row.",30,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"t"}}],[11,"get_checked","","Get the value of a particular column of the result row.",30,{"inputs":[{"name":"self"},{"name":"i"}],"output":{"name":"result"}}],[11,"column_count","","Return the number of columns in the current row.",30,{"inputs":[{"name":"self"}],"output":{"name":"i32"}}]],"paths":[[4,"DropBehavior"],[4,"TransactionBehavior"],[4,"Error"],[4,"DatabaseName"],[4,"FromSqlError"],[4,"ToSqlOutput"],[4,"Value"],[4,"ValueRef"],[4,"Type"],[3,"Null"],[8,"FromSql"],[8,"ToSql"],[3,"Transaction"],[3,"Savepoint"],[3,"Connection"],[3,"CachedStatement"],[3,"Statement"],[3,"LoadExtensionGuard"],[3,"Progress"],[4,"StepResult"],[3,"Backup"],[8,"Aggregate"],[3,"Context"],[3,"ZeroBlob"],[3,"Blob"],[8,"RowIndex"],[3,"OpenFlags"],[3,"MappedRows"],[3,"AndThenRows"],[3,"Rows"],[3,"Row"]]};
initSearch(searchIndex);
